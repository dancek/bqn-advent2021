# Thanks to Leah whose solution taught me a lot of nice tricks and
# showed that Bellman-Ford is performant enough and array-y. I had
# tried Dijkstra but this is no lisp and implementing a priority queue
# and whatnot was just too arduous.
# 
# See https://github.com/leahneukirchen/adventofcode2021/blob/master/day15.bqn
# for the most beautiful array solution I've seen to this problem.

in â† âŸ¨
  "1163751742"
  "1381373672"
  "2136511328"
  "3694931569"
  "7463417111"
  "1319128137"
  "1359912421"
  "3125421639"
  "1293138521"
  "2311944581"
âŸ©
in â†© â€¢FLines "15.txt"
grid â† >'0'-ËœÂ¨in


# Got this idea from Leah too. Recursion in a 1-modifier feels weird
# but I think I do understand it. There's probably other syntax that
# could work too (eg. the 1-argument versions in BQNcrate).
_FixedPoint â† {ğ•©â‰¡ğ•¨ğ”½ğ•© ? ğ•© ; ğ•¨ğ•Šğ•¨ğ”½ğ•©}

Solve â† {ğ•Š grid:
  # initialize âˆ cost except top-left corner (start) is 0
  cost â† 0âŒ¾âŠ‘âˆÃ—grid
  
  # The idea of Bellman-Ford: calculate lowest cost from neighbors on
  # every iteration. This is array-y because you can do it for the whole
  # grid at once by shifting the array (filling the border with âˆ),
  # adding edge cost and picking minimum throughout.
  infs â† âˆÃ—âŠgrid

  # Step is defined inside Solve so infs can be caught in the closure.
  Step â† {grid ğ•Š cost:
    min_neighbor â† (infsÂ«cost) âŒŠ (infsÂ»cost) âŒŠ (âˆÂ«Ë˜cost) âŒŠ (âˆÂ»Ë˜cost)
    cost âŒŠ grid+min_neighbor
  }

  # Run steps until the cost array doesn't change
  solution â† grid Step _FixedPoint cost

  # The answer is the cost to the bottom-right element
  Â¯1â€¿Â¯1 âŠ‘ solution
}

â€¢Show Solve grid

fullgrid â† 1+9|1-Ëœâˆ¾(<grid)+5â†•â†•9
â€¢Show Solve fullgrid

# Runtime was ~50s, ie. almost but not quite forever. But this is much
# much much more readable than the Dijkstra version could have ever
# been.
