Split â† ((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)

in â† (<"") âˆ¾ â€¢FLines "19.txt"
scanners â† >Â¨{â€¢BQN "âŸ¨"âˆ¾ğ•©âˆ¾"âŸ©"}Â¨Â¨2â†“Â¨1â†“inâŠ”Ëœ+`""âŠ¸â‰¡Â¨in

aâ†1â€¿1â€¿1
bâ†2â€¿3â€¿5

Dist2 â† {+Â´Ã—Ëœğ•©-ğ•¨}
Nearest â† {v ğ•Š vs:
  vsâŠËœâ‹vâŠ¸Dist2Ë˜ vs
}

Features â† {ğ•Š vs:
  {ğ•Š v:
    vâŠ¸-Ë˜2â†‘1â†“v Nearest vs
  }Ë˜vs
}

Hash â† {âˆ§|Â¨â¥Šğ•©}

# this only works if the nearest two beacons to a beacon are never cut off ğŸ¤·
â€¢Show â‰ â·âˆ§HashË˜âˆ¾Â´FeaturesÂ¨scanners

# OK. Star 2. Do this properly.

# generate all rotations (and mirrorings, which doesn't matter here)
pm3 â† 1-2Ã—â¥Šâ†•2â€¿2â€¿2
base â† 3â€¿3â¥Š1â€¿0â€¿0â€¿0
rotations â† â¥Špm3Ã—Ë˜âŒœ(âŠ¢âˆ¾âŒ½Â¨)âŒ½âŸœbaseÂ¨â†•3

Rotate â† {+Ëğ•¨Ã—ğ•©}
FindRotation â† {feat1 ğ•Š feat2: rotationsâŠ‘Ëœ/{feat1â‰¡ğ•©âŠ¸RotateË˜feat2}Â¨rotations}

Run â† {points ğ•Š âŸ¨âŸ©: 1â€¿3â¥Š0;  
  points ğ•Š scs:
  # compute features and hashes
  feats â† Features points
  hashes â† HashË˜feats

  # take first unjoined scanner, compute features and hashes
  xs â† âŠ‘scs
  fs â† Features xs
  hs â† HashË˜fs
  matches â† hs (âˆŠ/âŠ£) hashes
  # if no matches, recurse with rotated scs
  {0=â‰ matches ? points Run 1âŒ½scs ;
    # take first matching hash, find its index in both `points` and `xs`
    m â† âŠmatches
    mi â† âŠ‘/mâŠ¸â‰¡Ë˜hs
    pi â† âŠ‘/mâŠ¸â‰¡Ë˜hashes
    mf â† miâŠfs
    pf â† piâŠfeats
    # find rotation and translation
    rot â† pf FindRotation mf
    tr â† (piâŠpoints) - rot Rotate miâŠxs
    # transform all `xs`
    ps â† {tr + rot Rotate ğ•©}Ë˜xs

    # recurse with joined and deduplicated points
    tr âˆ¾ (â· pointsâˆ¾ps) Run 1â†“scs
  }
}

scannerPositions â† (âŠ‘scanners) Run 1â†“scanners

Manhattan â† {+Â´|ğ•©-ğ•¨}
â€¢Show âŒˆÂ´â¥ŠManhattanâŒœËœ <Ë˜scannerPositions
